# 4. Pythonin perusteet jatkuvat

Seuraavassa osiossa syvennetään meidän Python-osaamista. Lue ja testaile koodinpätkiä QGISin Python-konsolissa.

### Silmukat ja iterointi

#### while-silmukka

Silmukka (loop) mahdollistaa samojen komentojen toistamisen useaan kertaan.
`while`-silmukassa koodilohkoa toistetaan niin pitkään,
kuin silmukan ehto on totta.

Syntaksi on muotoa:

::: code-box
```python
while <ehto>:
    <suoritettava koodi>
```
:::

`while`-silmukoissa on tärkeää, että emme luo niin sanottua ikuista silmukkaa:

::: code-box
```python
while True:
    print("this never ends")
```
:::

Tulostaa:
```
this never ends
this never ends
this never ends
...
(jatkuu loputtomasti)
```

Seuraava silmukka loppuu kolmen kierroksen jälkeen:

::: code-box
```python
number = 0

while number < 3:
    print(number)
    number = number + 1
```
:::

Tulostaa:
```
0
1
2
```

Silmukan voi myös lopettaa `break`-komennolla:

::: code-box
```python
number = 0

while True:
    print(number)
    number += 1  # lyhyempi tapa kirjoittaa number = number + 1
    if number >= 3:
        break
```
:::

Tulostaa:
```
0
1
2
```

#### for-silmukka

`for`-silmukassa toistaminen perustuu ehdon sijasta tietorakenteeseen.
Tarkemmin sanottuna `for`-silmukka käy läpi tietorakenteen kaikki osat yksi kerrallaan:
tätä kutsutaan iteroinniksi (iteration).
`for`-silmukan suoritus loppuu automaattisesti,
kun tietorakenne on läpikäyty.

Syntaksi on muotoa:

::: code-box
```python
for <muuttuja> in <rakenne>:
    <suoritettava koodi>
```
:::

`<muuttuja>`:n arvo siis riippuu tietorakenteesta.
Esimerkiksi listassa se saa arvokseen jokaisen listan alkion vuorollaan:

::: code-box
```python
my_list = [1, 2, 3]

for item in my_list:
    print(item)

for i in my_list:  # for-silmukan muuttuja voidaan nimetä miten vain
    print(i)
```
:::

Tulostaa:
```
1
2
3
1
2
3
```

Sanakirjoissa `for`-silmukan muuttuja on avain:

::: code-box
```python
coordinates = {"city_1": (10, 4), "city_2": (1, 3)}

for key in coordinates:
    print(f"avain: {key}")
    print(f"arvo: {coordinates[key]}")

# ... mutta sanakirja.items mahdollistaa sekä avaimen että arvon suoran käytön
for key, value in coordinates.items():
    print(key, value)
```
:::

Tulostaa:
```
avain: city_1
arvo: (10, 4)
avain: city_2
arvo: (1, 3)
city_1 (10, 4)
city_2 (1, 3)
```

Silmukoita voi olla sisäkkäin:

::: code-box
```python
list_of_lists = [[1, 2, 3], ["a", "b", "c"]]

for inner_list in list_of_lists:
    print(inner_list)
    for item in inner_list:
        print(item)
```
:::

Tulostaa:
```
[1, 2, 3]
1
2
3
['a', 'b', 'c']
a
b
c
```

`break`-komento toimii kaikissa silmukoissa:

::: code-box
```python
numbers = [1, 2, 3, "a cat", 5, 6]

for number in numbers:
    if type(number) != int and type(number) != float:
        print(f"{number} is not a number!")
        break
    print(number)
```
:::

Tulostaa:
```
1
2
3
a cat is not a number!
```

### Moduulit

Moduuli (module) on mikä vain `.py`-loppuinen tiedosto.
Se siis sisältää Python-koodia, esimerkiksi arvoja tai funktioita.
Moduulien hyöty piilee siinä,
että yhdessä moduulissa olevaa koodia voi käyttää muissa moduuleissa.
Näin koodin uudelleenkäytettävyys paranee huomattavasti.

Moduuli otetaan käyttöön `import` komennolla.
Alla otetaan käyttöön Pythonin sisäänrakennettu `math`-moduuli,
ja käytetään moduulin funktiota `sqrt` neliöjuuren laskemiseen:

::: code-box
```python
import math

print(math.sqrt(4))
```
:::

Tulostaa:
```
2.0
```

Moduulin osia voi ottaa käyttöön myös suoraan `from`-syntaksilla:

::: code-box
```python
from math import pi, sqrt

print(pi)
print(sqrt(4))
```
:::

Tulostaa:
```
3.141592653589793
2.0
```


## Syventävää tietoa

### Oliot

Olio (object) on keskeinen käsite Pythonissa.
Esimerkiksi kaikki kielessä esiintyvät arvot,
kuten luvut, merkkijonot tai listat,
ovat olioita -- kukin vain omaa tyyppiään.

#### Metodit ja attribuutit

Käytännössä olio tarkoittaa kokonaisuutta,
joka voi pitää sisällään tietoa sekä toiminaallisuuksia.
Esimerkiksi merkkijonoon liittyy itse merkkijonon lisäksi
olion toteuttamia toiminnalisuuksia eli metodeja (method).
Olioon liittyvää tietoa kutsutaan attribuutiksi (attribute).
Kunkin olion metodit ja attribuutit ovat sidottuja olion tyyppiin:
esim. kokonaisluku-olion metodit ovat merkkijonoon nähden erilaisia.

Tavallisista funktioista metodit eroavat siinä,
että niitä kutsutaan aina kohteena olevan olion kautta.
Sama pätee attribuutteihin:
toisin kuin tavallinen muuttuja, attribuutti haetaan olion kautta.
Alla esimerkki syntaksista:

::: code-box
```python
my_object.method()   # metodikutsu
my_object.attribute  # attribuutti
```
:::

Alla esimerkki merkkijonon metodista `count`,
joka laskee kuinka monta kertaa parametrina annettu merkkijono sisältyy
kohdemerkkijonoon:

::: code-box
```python
print("abcdeeee".count("e"))
```
:::

Tulostaa:
```
4
```

Lista-olion metodi `sort`:

::: code-box
```python
my_list = [3, 1, 2]

my_list.sort()

print(my_list)
```
:::

Tulostaa:
```
[1, 2, 3]
```

Totuusarvolla on attribuutti `real`,
joka on kohdetotuusarvo reaalilukuna:

::: code-box
```python
print(True.real)
print(False.real)
```
:::

Tulostaa:
```
1
0
```

#### Konstruktorit

Tähän mennessä olioiden luomiseen ei olla kiinnitetty erityistä huomiota.
Monille pythonin sisäänrakennetuille tyypeille on tietty syntaksi,
jolla olio luodaan, esimerkkinä listan luominen hakasulkeilla `[]` tai merkkijono
lainausmerkeillä `""`.

Yllämainitut tapaukset ovat kuitenkin erikoistapauksia:
kaikkien eri tyyppien olioiden muodostamiseen ei ole sisäänrakennettua syntaksia.
Oletusarvoisesti olio luodaankin konstruktorilla (constructor),
joka on olion muodostamiseen tarkoitettu metodi.
Muista metodeista eroten konstruktoria kutsutaan irrallaan oliosta,
sillä oliota ei ole olemassa ennen konstruktorikutsua.

Esimerkkinä päivämäärän, eli `date`-tyypin olion, luominen:

::: code-box
```python
from datetime import date

my_date = date(year=2024, month=6, day=19)

print(my_date)
print(type(my_date))
print(my_date.year)
print(my_date.isoweekday())
```
:::

Tulostaa:
```
2024-06-19
<class 'datetime.date'>
2024
3
```

`date` on siis konstruktori,
jota kutsuttaessa annettiin vuosi, kuukausi ja päivä.
Näin saatiin `date`-olio, johon liittyy monia attribuutteja ja metodeja:
esim. tieto sen vuodesta ja metodi iso-formaatin viikonpäivän hakemiseen.

### Luokat

Olioiden attribuutit ja metodit määritellään luokissa (class).
Toisin sanottuna luokka on siis tapa määritellä omia tyyppejä.

#### Luokan syntaksi

Luokka määritellään avainsanalla `class`.
Luokan sisällä on tyypillisesti konstruktori,
eli `__init__`-metodi.
Tätä metodia kutsutaan taustalla silloin kun luokasta luodaan uusi olio.
Huomaa kuitenkin, että olio luodaan kutsumalla suoraan luokan nimeä,
eli luodessa ei kirjoitetakkaan erikseen `Luokka.__init__()`.

Myös luokan muut metodit määritellään sisennettynä `class`-lohkoon.
Metodit määritellään muuten samalla tavalla kuin mikä vain funktio,
mutta ensimmäiseksi parametriksi asetetaan `self`.
`self`-muuttujalla päästään käsiksi
luokan attribuutteihin ja metodeihin luokan määrittelyn sisällä.

Luokkien nimeämisessä hyödynnetään hyvien tyylisääntöjen mukaisesti CamelCase-notaatiota,
kun taas kaikessa muussa käytetään snake_case-notaatiota.

Esimerkki luokan määrittelystä ja käytöstä:

::: code-box
```python
class MyClass:  # nimetään luokka

    def __init__(self, parameter_1, parameter_2):  # konstruktori
        self.attribute_1 = parameter_1  # attribuuteja
        self.attribute_2 = parameter_2

    def method(self, parameter):
        print(f"{self.attribute_1}, {parameter}")

my_object = MyClass(1, "b")  # luodaan olio

print(type(my_object))
print(my_object.attribute_1)
print(my_object.attribute_2)
my_object.method("c")
```
:::

Tulostaa:
```
<class '__main__.MyClass'>
1
b
1, c
```

#### Luokkien hyödyntäminen ohjelmoinnissa

Luokilla voidaan mallintaa kokonaisuuksia,
joiden tiedot ja toiminnallisuudet liittyvät loogisesti yhteen.

Alla yksinkertainen esimerkki luokasta `Animal`:

::: code-box
```python
class Animal:

    def __init__(self, species, sound, name="Nimetön"):
        self.species = species
        self.sound = sound
        self.name = name

    def describe(self):
        print(f"Nimi: {self.name}")
        print(f"Laji: {self.species}")

    def speak(self):
        print(self.sound)

cat = Animal(species="kissa", sound="Miau!")
dog = Animal(species="koira", sound="Vuh!", name="Kerttu")

cat.describe()
cat.speak()

dog.describe()
dog.speak()
```
:::

Tulostaa:
```
Nimi: Nimetön
Laji: kissa
Miau!
Nimi: Kerttu
Laji: koira
Vuh!
```

Alla edistyneempi esimerkki,
jossa useampia luokkia käytetään yhdessä
mallintamaan ostotapahtumaa kaupassa.
Esimerkissä määritellään kolme luokkaa:
tuote (`Item`), jolla on attribuutteina nimi ja hinta,
asiakas (`Customer`),
jolla on attribuutteina rahaa ja tuotteita sekä metodi maksamiseen,
ja kassa (`Counter`), jossa on rahaa ja jolla on metodi
maksun veloitukseen asiakkaalta.
Lisäksi `Customer`- ja `Counter`-luokille
on toteutettu `show_info`-metodi,
jotta ohjelman suorituksen seuraaminen olisi helpompaa.

::: code-box
```python
# Määritellään luokat
class Item:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Customer:

    def __init__(self, money):
        self.money = money
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def pay(self, price):
        self.money -= price

    def show_info(self):
        print("Customer items:")
        for item in self.items:
            print(f"{item.name}, price: {item.price}")
        print(f"Customer money: {self.money}")
        print("----")


class Counter:

    def __init__(self):
        self.money = 100

    def make_purchase(self, customer):
        total_price = 0
        for item in customer.items:
            total_price += item.price
        customer.pay(total_price)
        self.money += total_price

    def show_info(self):
        print(f"Money in counter: {self.money}")
        print("----")


# Käytetään luokkia
banana = Item(name="banana", price=1)
coffee = Item(name="coffee", price=6)

customer = Customer(money=10)

counter = Counter()

customer.show_info()
counter.show_info()

customer.add_item(item=banana)
customer.add_item(item=coffee)
customer.show_info()

counter.make_purchase(customer=customer)

customer.show_info()
counter.show_info()
```
:::

Tulostaa:
```
Customer items:
Customer money: 10
----
Money in counter: 100
----
Customer items:
banana, price: 1
coffee, price: 6
Customer money: 10
----
Customer items:
banana, price: 1
coffee, price: 6
Customer money: 3
----
Money in counter: 107
----
```



### Lisävinkkejä konsolin käyttöön:

- Konsoli sopii hyvin myös esimerkiksi PyQGIS-olioiden ominaisuuksien tutkimiseen sekä testailuun, ja se tukee esimerkiksi PyQGIS-kirjastojen koodintäydennystä (code completion).
- Konsolissa voi myös suorittaa useammalle riville jatkuvia komentoja, kuten for-loopin. Konsoliin ilmestyy tällöin rivinvaihdon jälkeen kolme pistettä sen merkiksi, että se odottaa lisäkomentoja. Huomaa kuitenkin, että pisteet eivät vastaa Python-koodin sisennystä, vaan käyttäjän on huolehdittava tästä.
- Nuolinäppäimillä ylös- ja alaspäin pääsee siirtymään konsoliin syötettyjen komentojen historiassa.
- Konsolipaneeli aukeaa todennäköisesti karttaikkunan alapuolelle, mutta sen pystyy raahaamaan ja telakoimaan haluttaessa muuallekin QGISin käyttöliittymässä tai irrottamaan omaksi ikkunakseen.


